---
title: Automatic GraphQL Filter Generation
author: Ariel Mashraki
authorURL: "https://github.com/a8m"
authorImageURL: "https://avatars0.githubusercontent.com/u/7413593"
authorTwitter: arielmashraki
---

#### 摘要

我们为Ent GraphQL扩展新增了一项集成功能，能够从`ent/schema`生成类型安全的GraphQL过滤器（即`Where`谓词），并允许用户将GraphQL查询无缝映射到Ent查询。

例如，要获取所有状态为`COMPLETED`的待办事项，可以执行以下查询：

````graphql
query QueryAllCompletedTodos {
  todos(
    where: {
      status: COMPLETED,
    },
  ) {
    edges {
      node {
        id
      }
    }
  }
}
````

生成的GraphQL过滤器遵循Ent语法。这意味着以下查询同样有效：

```graphql
query FilterTodos {
  todos(
    where: {
      or: [
        {
          hasParent: false,
          status: COMPLETED,
        },
        {
          status: IN_PROGRESS,
          hasParentWith: {
            priorityLT: 1,
            statusNEQ: COMPLETED,
          },
        }
      ]
    },
  ) {
    edges {
      node {
        id
      }
    }
  }
}
```

### 背景

许多处理Go数据的库选择使用空接口实例（`interface{}`）并通过运行时反射来映射数据结构。除了反射带来的性能损耗外，这种方式对开发团队最大的负面影响在于丧失了类型安全性。

当API具备显式声明、编译时可知的特性时，开发者能即时获得关于各类错误的反馈。大量缺陷得以早期发现，开发体验也会更加愉悦！

Ent的设计初衷是为处理大型数据模型的团队提供卓越的开发体验。为此我们早期就确立了一个核心设计原则："通过代码生成实现静态类型化的显式API"。这意味着开发者定义的每个`ent/schema`实体都会生成显式、类型安全的代码来高效操作数据。例如在[Ent代码库的文件系统示例](https://github.com/ent/ent/blob/master/examples/fs/)中可以看到一个`File`模式：

```go
// File holds the schema definition for the File entity.
type File struct {
	ent.Schema
}
// Fields of the File.
func (File) Fields() []ent.Field {
	return []ent.Field{
		field.String("name"),
		field.Bool("deleted").
			Default(false),
		field.Int("parent_id").
			Optional(),
	}
}
```

当Ent代码生成器运行时，会创建众多谓词函数。例如以下用于按`name`字段过滤`File`的函数：

```go
package file
// .. truncated ..

// Name applies the EQ predicate on the "name" field.
func Name(v string) predicate.File {
	return predicate.File(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldName), v))
	})
}
```

[GraphQL](https://graphql.org)是Facebook创建的API查询语言。与Ent类似，GraphQL使用图的概念建模数据并支持类型安全查询。约一年前，我们发布了Ent与GraphQL的集成方案。与[gRPC集成](2021-06-28-gprc-ready-for-use.md)类似，该集成旨在帮助开发者轻松创建与Ent对接的API服务，实现对数据库数据的增删改查。

### 自动生成GraphQL过滤器

在最近的社区调研中，Ent+GraphQL集成被列为最受用户喜爱的功能之一。此前该集成仅支持基础数据查询。今天我们宣布推出一项将开启更多应用场景的新功能："自动生成GraphQL过滤器"。

如前所述，Ent代码生成器会在Go代码库中维护一系列谓词函数，让我们能显式地过滤数据库表数据。这项能力此前并未（至少未自动）提供给Ent+GraphQL集成的用户。通过自动生成GraphQL过滤器，开发者只需单行配置变更，即可在GraphQL模式中获得完整的"过滤输入类型"，用作查询谓词。系统还提供运行时代码来解析这些谓词并映射为Ent查询。请看具体示例：

### 生成过滤输入类型

要为`ent/schema`中的每个类型生成过滤输入（如`TodoWhereInput`），请按以下方式编辑`ent/entc.go`配置文件：

```go
// +build ignore

package main

import (
	"log"

	"entgo.io/contrib/entgql"
	"entgo.io/ent/entc"
	"entgo.io/ent/entc/gen"
)

func main() {
	ex, err := entgql.NewExtension(
		entgql.WithWhereFilters(true),
		entgql.WithConfigPath("../gqlgen.yml"),
		entgql.WithSchemaPath("<PATH-TO-GRAPHQL-SCHEMA>"),
	)
	if err != nil {
		log.Fatalf("creating entgql extension: %v", err)
	}
	err = entc.Generate("./schema", &gen.Config{}, entc.Extensions(ex))
	if err != nil {
		log.Fatalf("running ent codegen: %v", err)
	}
}
```

若您刚接触Ent和GraphQL，请遵循[入门教程](https://entgo.io/docs/tutorial-todo-gql)开始使用。

接下来，运行 `go generate ./ent/...`。您会注意到 Ent 已为 schema 中的每个类型生成了 `<T>WhereInput` 类型。Ent 会自动更新 GraphQL schema，因此您无需手动将它们绑定到 `gqlgen`。例如：

```go title="ent/where_input.go"
// TodoWhereInput represents a where input for filtering Todo queries.
type TodoWhereInput struct {
	Not *TodoWhereInput   `json:"not,omitempty"`
	Or  []*TodoWhereInput `json:"or,omitempty"`
	And []*TodoWhereInput `json:"and,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "status" field predicates.
	Status      *todo.Status  `json:"status,omitempty"`
	StatusNEQ   *todo.Status  `json:"statusNEQ,omitempty"`
	StatusIn    []todo.Status `json:"statusIn,omitempty"`
	StatusNotIn []todo.Status `json:"statusNotIn,omitempty"`

    // .. truncated ..
}
```

```graphql title="todo.graphql"
"""
TodoWhereInput is used for filtering Todo objects.
Input was generated by ent.
"""
input TodoWhereInput {
  not: TodoWhereInput
  and: [TodoWhereInput!]
  or: [TodoWhereInput!]
  
  """created_at field predicates"""
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  
  """status field predicates"""
  status: Status
  statusNEQ: Status
  statusIn: [Status!]
  statusNotIn: [Status!]
    
  # .. truncated ..
}
```

要完成集成，我们还需要进行两项调整：

1\. 编辑 GraphQL schema 以接受新的过滤器类型：

```graphql {8}
type Query {
  todos(
    after: Cursor,
    first: Int,
    before: Cursor,
    last: Int,
    orderBy: TodoOrder,
    where: TodoWhereInput,
  ): TodoConnection!
}
```

2\. 在 GraphQL 解析器中使用新的过滤器类型：

```go {5}
func (r *queryResolver) Todos(ctx context.Context, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.TodoOrder, where *ent.TodoWhereInput) (*ent.TodoConnection, error) {
	return r.client.Todo.Query().
		Paginate(ctx, after, first, before, last,
			ent.WithTodoOrder(orderBy),
			ent.WithTodoFilter(where.Filter),
		)
}
```

### 过滤器规范

如前所述，通过新的 GraphQL 过滤器类型，您可以表达与 Go 代码中相同的 Ent 过滤器。

#### 逻辑与、或及非运算

可通过 `not`、`and` 和 `or` 字段添加 `Not`、`And` 和 `Or` 运算符。例如：

```graphql
{
  or: [
    {
      status: COMPLETED,
    },
    {
      not: {
        hasParent: true,
        status: IN_PROGRESS,
      }
    }
  ]
}
```

当提供多个过滤字段时，Ent 会隐式添加 `And` 运算符。

```graphql
{
  status: COMPLETED,
  textHasPrefix: "GraphQL",
}
```

上述查询将生成以下 Ent 查询：

```go
client.Todo.
	Query().
	Where(
		todo.And(
			todo.StatusEQ(todo.StatusCompleted),
			todo.TextHasPrefix("GraphQL"),
		)
	).
	All(ctx)
```

#### 边/关系过滤器

[边（关系）谓词](https://entgo.io/docs/predicates#edge-predicates)可以用相同的 Ent 语法表达：

```graphql
{
  hasParent: true,
  hasChildrenWith: {
    status: IN_PROGRESS,
  }
}
```

上述查询将生成以下 Ent 查询：

```go
client.Todo.
	Query().
	Where(
		todo.HasParent(),
		todo.HasChildrenWith(
			todo.StatusEQ(todo.StatusInProgress),
		),
	).
	All(ctx)
```

### 实现示例

完整示例请参见 [github.com/a8m/ent-graphql-example](https://github.com/a8m/ent-graphql-example)。

### 总结

正如前文所述，Ent 将"通过代码生成创建静态类型化且显式的 API"作为核心设计原则。通过自动生成 GraphQL 过滤器，我们进一步强化了这一理念，为开发者在 RPC 层提供同样显式、类型安全的开发体验。

有问题需要解答？需要入门帮助？欢迎加入我们的 [Discord 服务器](https://discord.gg/qZmPgTE6RX) 或 [Slack 频道](https://entgo.io/docs/slack)。

:::note[获取更多 Ent 资讯：]

- 订阅我们的 [新闻通讯](https://entgo.substack.com/)
- 关注 [Twitter 官方账号](https://twitter.com/entgo_io)
- 加入 [Gophers Slack](https://entgo.io/docs/slack) 的 #ent 频道
- 加入 [Ent Discord 服务器](https://discord.gg/qZmPgTE6RX)

:::