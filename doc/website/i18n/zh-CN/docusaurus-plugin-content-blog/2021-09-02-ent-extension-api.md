---
title: Extending Ent with the Extension API
author: Rotem Tamir
authorURL: "https://github.com/rotemtam"
authorImageURL: "https://s.gravatar.com/avatar/36b3739951a27d2e37251867b7d44b1a?s=80"
authorTwitter: _rtam
---

数月前，[Ariel](https://github.com/a8m) 为 Ent 核心代码库默默提交了一个影响深远的贡献——[扩展 API](https://entgo.io/docs/extensions)。虽然 Ent 长期支持扩展功能（如[代码生成钩子](https://entgo.io/docs/code-gen/#code-generation-hooks)、[外部模板](https://entgo.io/docs/templates/)和[注解](https://entgo.io/docs/templates/#annotations)），但此前缺乏将所有这些组件打包成独立、自包含模块的便捷方式。本文讨论的[扩展 API](https://entgo.io/docs/extensions) 正是为此而生。

许多开源生态系统的繁荣，恰恰源于它们为开发者提供了扩展小型核心系统的结构化捷径。Node.js 生态虽饱受争议（甚至被[其创始人 Ryan Dahl 批评](https://www.youtube.com/watch?v=M3BM9TB-8yA)），但不可否认 npm 模块极低的发布与使用门槛极大推动了其流行。我在个人博客中分析过[protoc 插件系统](https://rotemtam.com/2021/03/22/creating-a-protoc-plugin-to-gen-go-code/)如何促进 Protobuf 生态繁荣。简言之，唯有模块化设计才能孕育生态系统。

本文将通过构建示例项目来探索 Ent 的 `Extension` API。

### 快速开始

扩展 API 仅适用于将 Ent 代码生成[作为 Go 包使用](https://entgo.io/docs/code-gen/#use-entc-as-a-package)的项目。初始化项目后，创建 `ent/entc.go` 文件：

```go title=ent/entc.go
//+build ignore

package main

import (
    "log"

    "entgo.io/ent/entc"
    "entgo.io/ent/entc/gen"
    "entgo.io/ent/schema/field"
)

func main() {
    err := entc.Generate("./schema", &gen.Config{})
    if err != nil {
        log.Fatal("running ent codegen:", err)
    }
}
```

接着修改 `ent/generate.go` 来调用我们的 `entc` 文件：

```go title=ent/generate.go
package ent

//go:generate go run entc.go
```

### 创建扩展

所有扩展必须实现 [Extension](https://pkg.go.dev/entgo.io/ent/entc#Extension) 接口：

```go
type Extension interface {
	// Hooks holds an optional list of Hooks to apply
	// on the graph before/after the code-generation.
	Hooks() []gen.Hook
	// Annotations injects global annotations to the gen.Config object that
	// can be accessed globally in all templates. Unlike schema annotations,
	// being serializable to JSON raw value is not mandatory.
	//
	//	{{- with $.Config.Annotations.GQL }}
	//		{{/* Annotation usage goes here. */}}
	//	{{- end }}
	//
	Annotations() []Annotation
	// Templates specifies a list of alternative templates
	// to execute or to override the default.
	Templates() []*gen.Template
	// Options specifies a list of entc.Options to evaluate on
	// the gen.Config before executing the code generation.
	Options() []Option
}
```

为简化扩展开发，开发者可嵌入 [entc.DefaultExtension](https://pkg.go.dev/entgo.io/ent/entc#DefaultExtension) 来避免实现所有方法。在 `entc.go` 中添加：

```go title=ent/entc.go
// ...

// GreetExtension implements entc.Extension.
type GreetExtension {
	entc.DefaultExtension
}
```

当前扩展尚未实现功能。接下来将其接入代码生成配置，在 `entc.go` 的 `entc.Generate` 调用中添加扩展：

```go
err := entc.Generate("./schema", &gen.Config{}, entc.Extensions(&GreetExtension{})
```

### 添加模板

外部模板可打包进扩展以增强核心代码生成功能。本示例中，我们将为每个实体类型生成返回类型名问候语的 `Greet` 方法，目标效果如下：

```go
func (u *User) Greet() string {
    return "Greetings, User"
}
```

创建外部模板文件 `ent/templates/greet.tmpl`：

```gotemplate title="ent/templates/greet.tmpl"
{{ define "greet" }}

    {{/* Add the base header for the generated file */}}
    {{ $pkg := base $.Config.Package }}
    {{ template "header" $ }}

    {{/* Loop over all nodes and add the Greet method */}}
    {{ range $n := $.Nodes }}
        {{ $receiver := $n.Receiver }}
        func ({{ $receiver }} *{{ $n.Name }}) Greet() string {
            return "Greetings, {{ $n.Name }}"
        }
    {{ end }}
{{ end }}
```

接着实现 `Templates` 方法：

```go title="ent/entc.go"
func (*GreetExtension) Templates() []*gen.Template {
	return []*gen.Template{
		gen.MustParse(gen.NewTemplate("greet").ParseFiles("templates/greet.tmpl")),
	}
}
```

现在测试扩展功能。在 `ent/schema/user.go` 中创建 `User` 类型 schema：

```go
package schema

import (
	"entgo.io/ent"
	"entgo.io/ent/schema/field"
)

// User holds the schema definition for the User entity.
type User struct {
	ent.Schema
}

// Fields of the User.
func (User) Fields() []ent.Field {
	return []ent.Field{
		field.String("email_address").
			Unique(),
	}
}
```

运行生成命令：

```shell
go generate ./...
```

观察新生成的 `ent/greet.go` 文件：

```go title="ent/greet.go"
// Code generated by ent, DO NOT EDIT.

package ent

func (u *User) Greet() string {
	return "Greetings, User"
}
```

成功！我们的扩展在代码生成阶段被调用，并输出了预期的 schema 代码！

### 添加注解

注解（Annotations）为扩展用户提供了通过API修改代码生成逻辑行为的途径。要为我们的扩展添加注解功能，需实现`Annotations`方法。假设我们希望为`GreetExtension`提供配置生成代码中问候语的能力：

```go
// GreetingWord implements entc.Annotation
type GreetingWord string

func (GreetingWord) Name() string {
	return "GreetingWord"
}
```

首先在`GreetExtension`结构体中添加`word`字段：

```go
type GreetExtension struct {
	entc.DefaultExtension
	Word GreetingWord
}
```

接着实现`Annotations`方法：

```go
func (s *GreetExtension) Annotations() []entc.Annotation {
	return []entc.Annotation{
		s.Word,
	}
}
```

现在模板中即可访问`GreetingWord`注解。修改`ent/templates/greet.tmpl`以使用新注解：

```gotemplate
func ({{ $receiver }} *{{ $n.Name }}) Greet() string {
    return "{{ $.Annotations.GreetingWord }}, {{ $n.Name }}"
}
```

然后修改代码生成配置来设置GreetingWord注解：

```go title="ent/entc.go
err := entc.Generate("./schema",
    &gen.Config{},
    entc.Extensions(&GreetExtension{
        Word: GreetingWord("Shalom"),
    }),
)
```

重新运行以下命令查看注解对生成代码的控制效果：

```shell
go generate ./...
```

最终可观察到生成的`ent/greet.go`文件已更新：

```go
func (u *User) Greet() string {
	return "Shalom, User"
}
```

成功！我们通过注解实现了对生成代码中问候词汇的可配置化！

### 更多可能性

除模板和注解外，Extension API还允许开发者通过捆绑`gen.Hook`和`entc.Option`来进一步控制代码生成行为。本文不展开讨论这些功能，如需了解可查阅[官方文档](https://entgo.io/docs/extensions)。

### 总结

本文通过示例演示了如何使用`Extension` API创建Ent代码生成扩展。正如前文所述，允许扩展核心功能的模块化设计是任何生态系统成功的关键。我们看到Ent社区已涌现出多个优秀扩展项目：

* [elk](https://github.com/masseelch/elk) - 从Ent模式生成REST端点的扩展
* [entgql](https://github.com/ent/contrib/tree/master/entgql) - 从Ent模式生成GraphQL服务
* [entviz](https://github.com/hedwigz/entviz) - 从Ent模式生成ER图

您是否也有创建Ent扩展的想法？希望本文能证明借助Extension API实现这一目标并不困难。

若有疑问或需要入门帮助，欢迎加入我们的[Discord服务器](https://discord.gg/qZmPgTE6RX)或[Slack频道](https://entgo.io/docs/slack/)。

:::note[获取更多Ent资讯：]

- 订阅[新闻简报](https://entgo.substack.com/)
- 关注[Twitter](https://twitter.com/entgo_io)
- 加入[Gophers Slack](https://entgo.io/docs/slack)的#ent频道
- 加入[Ent Discord服务器](https://discord.gg/qZmPgTE6RX)

:::