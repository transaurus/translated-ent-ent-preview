---
id: tutorial-todo-gql-filter-input
title: Filter Inputs
sidebar_label: Filter Inputs
---

本节我们将延续[GraphQL示例](tutorial-todo-gql.mdx)，讲解如何从`ent/schema`生成类型安全的GraphQL过滤器（即`Where`谓词），并让用户能无缝地将GraphQL查询映射到Ent查询。例如，以下GraphQL查询会映射到对应的Ent查询：

**GraphQL**

```graphql
{
  hasParent: true,
  hasChildrenWith: {
    status: IN_PROGRESS,
  }
}
```

**Ent**

```go
client.Todo.
    Query().
    Where(
        todo.HasParent(),
        todo.HasChildrenWith(
            todo.StatusEQ(todo.StatusInProgress),
        ),
    ).
    All(ctx)
```

#### 克隆代码（可选）

本教程代码托管在[github.com/a8m/ent-graphql-example](https://github.com/a8m/ent-graphql-example)，每个步骤都有对应的Git标签。若想跳过基础配置直接使用GraphQL服务器的初始版本，可克隆仓库并按如下方式运行：

```console
git clone git@github.com:a8m/ent-graphql-example.git
cd ent-graphql-example 
go run ./cmd/todo/
```

### 配置Ent

在`ent/entc.go`文件中添加以下4个高亮行（扩展选项）：

```go {3-6} title="ent/entc.go"
func main() {
	ex, err := entgql.NewExtension(
		entgql.WithSchemaGenerator(),
		entgql.WithWhereInputs(true),
		entgql.WithConfigPath("gqlgen.yml"),
		entgql.WithSchemaPath("ent.graphql"),
	)
	if err != nil {
		log.Fatalf("creating entgql extension: %v", err)
	}
	opts := []entc.Option{
		entc.Extensions(ex),
		entc.TemplateDir("./template"),
	}
	if err := entc.Generate("./schema", &gen.Config{}, opts...); err != nil {
		log.Fatalf("running ent codegen: %v", err)
	}
} 
```

`WithWhereInputs`选项启用过滤器生成，`WithConfigPath`配置`gqlgen`配置文件路径以便更精准地映射GraphQL与Ent类型，`WithSchemaPath`则指定生成过滤器时写入的新建或现有GraphQL模式路径。

修改`entc.go`配置后，执行以下代码生成命令：

```console
go generate .
```

此时Ent会在`ent/gql_where_input.go`中为每个schema类型生成`<T>WhereInput`结构体，同时自动生成GraphQL模式文件(`ent.graphql`)，无需手动绑定到`gqlgen`。例如：

```go title="ent/gql_where_input.go"
// TodoWhereInput represents a where input for filtering Todo queries.
type TodoWhereInput struct {
	Not *TodoWhereInput   `json:"not,omitempty"`
	Or  []*TodoWhereInput `json:"or,omitempty"`
	And []*TodoWhereInput `json:"and,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "status" field predicates.
	Status      *todo.Status  `json:"status,omitempty"`
	StatusNEQ   *todo.Status  `json:"statusNEQ,omitempty"`
	StatusIn    []todo.Status `json:"statusIn,omitempty"`
	StatusNotIn []todo.Status `json:"statusNotIn,omitempty"`

    // .. truncated ..
}
```

```graphql title="ent.graphql"
"""
TodoWhereInput is used for filtering Todo objects.
Input was generated by ent.
"""
input TodoWhereInput {
  not: TodoWhereInput
  and: [TodoWhereInput!]
  or: [TodoWhereInput!]
  
  """created_at field predicates"""
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  
  """status field predicates"""
  status: Status
  statusNEQ: Status
  statusIn: [Status!]
  statusNotIn: [Status!]
    
  # .. truncated ..
}
```

:::info
若项目包含多个GraphQL模式文件（如`todo.graphql`和`ent.graphql`），需按如下方式配置`gqlgen.yml`：

```yaml
schema:
  - todo.graphql
  # ent.graphql由Ent自动生成
  - ent.graphql
```
:::

### 配置GQL

完成代码生成后，即可通过以下步骤在GraphQL中启用过滤功能：

1\. 修改GraphQL模式以支持新过滤器类型：

```graphql {8} title="ent.graphql"
type Query {
  todos(
    after: Cursor,
    first: Int,
    before: Cursor,
    last: Int,
    orderBy: TodoOrder,
    where: TodoWhereInput,
  ): TodoConnection!
}
```

2\. 在GraphQL解析器中使用新过滤器类型：

```go {5} title="ent.resolvers.go"
func (r *queryResolver) Todos(ctx context.Context, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.TodoOrder, where *ent.TodoWhereInput) (*ent.TodoConnection, error) {
	return r.client.Todo.Query().
		Paginate(ctx, after, first, before, last,
			ent.WithTodoOrder(orderBy),
			ent.WithTodoFilter(where.Filter),
		)
}
```

### 执行查询

通过新的GraphQL过滤器类型，您可以用与Go代码中相同的Ent过滤条件进行查询。

#### 逻辑与、或、非

可通过`not`、`and`和`or`字段在`where`子句中添加`Not`、`And`和`Or`运算符。例如：

```graphql {3-15}
query {
  todos(
    where: {
      or: [
        {
          status: COMPLETED
        },
        {
          not: {
            hasParent: true,
            status: IN_PROGRESS
          }
        }
      ]
    }
  ) {
    edges {
      node {
        id
        text
      }
      cursor
    }
  }
}
```

当提供多个过滤字段时，Ent会隐式添加`And`运算符。

```graphql
{
  status: COMPLETED,
  textHasPrefix: "GraphQL",
}
```

上述查询将生成如下Ent查询：

```go
client.Todo.
	Query().
	Where(
		todo.And(
			todo.StatusEQ(todo.StatusCompleted),
			todo.TextHasPrefix("GraphQL"),
		)
	).
	All(ctx)
```

#### 边/关系过滤器

[边(关系)谓词](https://entgo.io/docs/predicates#edge-predicates)可使用与Ent相同的语法：

```graphql
{
  hasParent: true,
  hasChildrenWith: {
    status: IN_PROGRESS,
  }
}
```

该查询将生成如下Ent查询：

```go
client.Todo.
	Query().
	Where(
		todo.HasParent(),
		todo.HasChildrenWith(
			todo.StatusEQ(todo.StatusInProgress),
		),
	).
	All(ctx)
```

### 自定义过滤器

有时我们需要向过滤器中添加自定义条件，虽然始终可以通过[模板](https://pkg.go.dev/entgo.io/contrib@master/entgql#WithTemplates)和[SchemaHooks](https://pkg.go.dev/entgo.io/contrib@master/entgql#WithSchemaHook)实现，但对于简单条件而言并非最便捷的方案。

幸运的是，结合使用[GraphQL对象类型扩展](https://spec.graphql.org/October2021/#sec-Object-Extensions)和自定义解析器，我们可以实现这一功能。

以下示例展示了如何添加自定义的`isCompleted`过滤器，该过滤器接收布尔值参数来筛选具有`completed`状态的待办事项。

首先扩展`TodoWhereInput`：

```graphql title="todo.graphql"
extend input TodoWhereInput {
  isCompleted: Boolean
}
```

执行代码生成后，我们会在`todo.resolvers.go`文件中看到新增的字段解析器：

```go title="todo.resolvers.go"
func (r *todoWhereInputResolver) IsCompleted(ctx context.Context, obj *ent.TodoWhereInput, data *bool) error {
	panic(fmt.Errorf("not implemented"))
}
```

现在可以通过`ent.TodoWhereInput`结构体中的`AddPredicates`方法实现自定义过滤逻辑：

```go title="todo.resolvers.go"
func (r *todoWhereInputResolver) IsCompleted(ctx context.Context, obj *ent.TodoWhereInput, data *bool) error {
	if obj == nil || data == nil {
		return nil
	}
	if *data {
		obj.AddPredicates(todo.StatusEQ(todo.StatusCompleted))
	} else {
		obj.AddPredicates(todo.StatusNEQ(todo.StatusCompleted))
	}
	return nil
}
```

该过滤器可像其他谓词一样使用：

```graphql
{
  isCompleted: true,
}
# including the not, and and or fields
{
  not: {
    isCompleted: true,
  }
}
```

### 作为谓词使用

`Filter`选项允许将生成的`WhereInput`作为常规谓词用于任何类型的查询：

```go
query := ent.Todo.Query()
query, err := input.Filter(query)
if err != nil {
	return nil, err
}
return query.All(ctx)
```

---

完成！如你所见，通过少量代码修改，我们的应用现在能自动将类型安全的GraphQL过滤器映射到Ent查询。如有疑问或需要入门帮助，欢迎加入我们的[Discord服务器](https://discord.gg/qZmPgTE6RX)或[Slack频道](https://entgo.io/docs/slack)。