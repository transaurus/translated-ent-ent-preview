---
title: Using Functional Indexes in Ent Schema
id: functional-indexes
slug: functional-indexes
---

import InstallationInstructions from '../components/_installation_instructions.mdx';

函数索引是一种基于表达式值（而非列值）构建的索引类型。这种索引适用于对未存储在表中的函数或表达式结果建立索引，目前被 [MySQL、MariaDB](https://atlasgo.io/guides/mysql/functional-indexes)、[PostgreSQL](https://atlasgo.io/guides/postgres/functional-indexes) 和 [SQLite](https://atlasgo.io/guides/sqlite/functional-indexes) 支持。

本指南将介绍如何通过函数索引扩展Ent schema，并配置Atlas实现将函数索引与Ent schema作为单一迁移单元进行管理。

:::info[[Atlas Pro功能](https://atlasgo.io/features#pro-plan)]
本指南使用的[复合Schema](https://atlasgo.io/atlas-schema/projects#data-source-composite_schema)功能为Pro版专属。使用前请执行：
```
atlas login
```
:::

## 安装Atlas

<InstallationInstructions />

## 登录Atlas

```shell
$ atlas login a8m
//highlight-next-line-info
You are now connected to "a8m" on Atlas Cloud.
```

## 复合Schema

`ent/schema`包通常用于定义Ent类型（对象）、字段、边关系和业务逻辑。由于Ent原生仅支持基于字段、边关系（外键）及其组合的索引，函数索引无法直接在Ent schema中表示。

若要在PostgreSQL迁移中为Ent类型（表）添加函数索引，需配置Atlas通过[复合Schema](https://atlasgo.io/atlas-schema/projects#data-source-composite_schema)数据源读取schema状态。具体配置步骤如下：

1\. 首先定义包含单个类型（表）的基础schema：`User`（对应表`users`）：

```go title="ent/schema/user.go"
// User holds the schema definition for the User entity.
type User struct {
	ent.Schema
}

// Fields of the User.
func (User) Fields() []ent.Field {
	return []ent.Field{
		field.String("name").
			Comment("A unique index is defined on lower(name) in schema.sql"),
	}
}
```

2\. 接着在`schema.sql`文件中为`name`字段定义函数索引：

```sql title="schema.sql" {2}
-- Create a functional (unique) index on the lowercased name column.
CREATE UNIQUE INDEX unique_name ON "users" ((lower("name")));
```

3\. 创建`atlas.hcl`配置文件，通过`composite_schema`同时包含`schema.sql`定义的函数索引和Ent schema：

```hcl title="atlas.hcl"
data "composite_schema" "app" {
  # Load the ent schema first with all tables.
  schema "public" {
    url = "ent://ent/schema"
  }
  # Then, load the functional indexes.
  schema "public" {
    url = "file://schema.sql"
  }
}

env "local" {
  src = data.composite_schema.app.url
  dev = "docker://postgres/15/dev?search_path=public"
}
```

## 使用指南

完成复合Schema配置后，可通过`atlas schema inspect`命令获取其SQL表示、生成迁移文件、应用到数据库等。以下是Atlas的常用命令示例：

#### 查看Schema结构

`atlas schema inspect`命令通常用于查看数据库结构，但也可用于查看`composite_schema`并输出其SQL表示：

```shell
atlas schema inspect \
  --env local \
  --url env://src \
  --format '{{ sql . }}'
```

该命令将输出如下SQL语句：

```sql
-- Create "users" table
CREATE TABLE "users" ("id" bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY, "name" character varying NOT NULL, PRIMARY KEY ("id"));
-- Create index "unique_name" to table: "users"
CREATE UNIQUE INDEX "unique_name" ON "users" ((lower((name)::text)));
```

注意输出中包含我们在`users`表的`name`字段上定义的函数索引。

#### 生成Schema迁移文件

执行以下命令生成schema迁移文件：

```shell
atlas migrate diff \
  --env local
```

此时会创建包含以下内容的新迁移文件：

```sql title="migrations/20240712090543.sql"
-- Create "users" table
CREATE TABLE "users" ("id" bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY, "name" character varying NOT NULL, PRIMARY KEY ("id"));
-- Create index "unique_name" to table: "users"
CREATE UNIQUE INDEX "unique_name" ON "users" ((lower((name)::text)));
```

#### 应用迁移

执行以下命令将生成的迁移应用到数据库：

```
atlas migrate apply \
  --env local \
  --url "postgres://postgres:pass@localhost:5432/database?search_path=public&sslmode=disable"
```

:::info[直接向数据库应用模式]

有时需要不生成迁移文件而直接将模式应用到数据库。例如，在试验模式变更、为测试启动数据库等场景中。此时可以使用以下命令直接将模式应用到数据库：

```shell
atlas schema apply \
  --env local \
  --url "postgres://postgres:pass@localhost:5432/database?sslmode=disable"
```

或使用 [Atlas Go SDK](https://github.com/ariga/atlas-go-sdk)：

```go
ac, err := atlasexec.NewClient(".", "atlas")
if err != nil {
	log.Fatalf("failed to initialize client: %w", err)
}
// 自动用期望的模式更新数据库
// 另一种选择是手动使用 'migrate apply' 或 'schema apply'
if _, err := ac.SchemaApply(ctx, &atlasexec.SchemaApplyParams{
	Env: "local",
	URL: "postgres://postgres:pass@localhost:5432/database?sslmode=disable",
	AutoApprove: true,
}); err != nil {
    log.Fatalf("failed to apply schema changes: %w", err)
}
```

:::

## 代码示例

在设置好带函数索引的Ent模式后，我们预期数据库会强制保证`users`表中`name`字段的唯一性：

```go
// Test that the unique index is enforced.
client.User.Create().SetName("Ariel").SaveX(ctx)
err = client.User.Create().SetName("ariel").Exec(ctx)
require.EqualError(t, err, `ent: constraint failed: pq: duplicate key value violates unique constraint "unique_name"`)

// Type-assert returned error.
var pqerr *pq.Error
require.True(t, errors.As(err, &pqerr))
require.Equal(t, `duplicate key value violates unique constraint "unique_name"`, pqerr.Message)
require.Equal(t, user.Table, pqerr.Table)
require.Equal(t, "unique_name", pqerr.Constraint)
require.Equal(t, pq.ErrorCode("23505"), pqerr.Code, "unique violation")
```

本指南的完整代码可在 [GitHub](https://github.com/ent/ent/tree/master/examples/functionalidx) 获取。